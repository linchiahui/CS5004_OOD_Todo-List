<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Options.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hw9</a> &gt; <a href="index.source.html" class="el_package">toDoApplication.view</a> &gt; <span class="el_source">Options.java</span></div><h1>Options.java</h1><pre class="source lang-java linenums">package toDoApplication.view;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * An Options object represents the collection of Options used for a program, which each describes
 * a possible command line argument for the program.
 */
public class Options {
  /**
   * A map of all the Options, with the key being their long-String representation,
   * and the value being the corresponding Option object.
   */
  private Map&lt;String, Option&gt; longOpts;

  /** A list of all the Options (their long-String form) that are required to run the given program. */
  private List&lt;String&gt; requiredOpts;

  /**
   * Constructor: creates a new Options object with its an empty map and list
   */
<span class="fc" id="L27">  public Options(){</span>
<span class="fc" id="L28">    this.longOpts = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L29">    this.requiredOpts = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L30">  }</span>

  /**
   * Gets the map: longname as key and Option as value
   *
   * @return the map:  longname as key and Option as value
   */
  public Map&lt;String, Option&gt; getLongOpts() {
<span class="fc" id="L38">    return this.longOpts;</span>
  }

  /**
   * Gets every Option that is required.
   *
   * @return Read-only List of all Option required (long-String representation)
   */
  public List&lt;String&gt; getRequiredOptions() {
<span class="fc" id="L47">    return this.requiredOpts;</span>
  }

  /**
   * This method adds a new Option to the existing set of Options
   *
   * @param opt The new Option to be added
   * @return The updated Options object
   */
  public Options addOption(Option opt) {
<span class="fc" id="L57">    String key = opt.getLongOpt();</span>

    // Add it to the map.
<span class="fc" id="L60">    this.longOpts.put(Utility.stripLeadingHyphens(key), opt);</span>

    // If the option is required, add it to the required list as well.
<span class="fc bfc" id="L63" title="All 2 branches covered.">    if (opt.isRequired()) {</span>
<span class="fc" id="L64">      this.requiredOpts.add(key);</span>
    }
<span class="fc" id="L66">    return this;</span>
  }

  /**
   * Given a long-String name of an Option, retrieves the corresponding Option.
   * Before retrieving, the leading hyphens in the long name are removed (up to 2).
   *
   * @param opt short or long name of the Option we want to look for
   * @return the corresponding Option, and null if the Option is not in the map
   */
  public Option getOption(String opt) {
<span class="fc" id="L77">    opt = Utility.stripLeadingHyphens(opt);</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">    if (this.longOpts.containsKey(opt)) {</span>
<span class="fc" id="L79">      return this.longOpts.get(opt);</span>
    }
<span class="fc" id="L81">    return null;</span>
  }

  /**
   * Returns all the Option objects having a long name starting with the specified string.
   *
   * @param opt The prefix/complete name of an Option
   * @return A list of all Option objects (list of their long names) matching the prefix/complete
   * name specified, or an empty list if none matches.
   */
  public List&lt;String&gt; getMatchingOptions(String opt) {
<span class="fc" id="L92">    opt = Utility.stripLeadingHyphens(opt);</span>
<span class="fc" id="L93">    List&lt;String&gt; matchingOpts = new ArrayList&lt;&gt;();</span>

    // If we have a perfect match, return that Option only
<span class="fc bfc" id="L96" title="All 2 branches covered.">    if (this.longOpts.keySet().contains(opt)) {</span>
<span class="fc" id="L97">      return Collections.singletonList(opt);</span>
    }

<span class="fc bfc" id="L100" title="All 2 branches covered.">    for (String longOpt : this.longOpts.keySet()) {</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">      if (longOpt.startsWith(opt)) {</span>
<span class="fc" id="L102">        matchingOpts.add(longOpt);</span>
      }
<span class="fc" id="L104">    }</span>
<span class="fc" id="L105">    return matchingOpts;</span>
  }

  /**
   * Given the long name of an Option, check whether the corresponding Option object is in this
   * Options set.
   *
   * @param opt long name of the Option
   * @return true if the corresponding Option is in this Options set, false if it is not.
   */
  public boolean hasOption(String opt) {
<span class="fc" id="L116">    opt = Utility.stripLeadingHyphens(opt);</span>
<span class="fc" id="L117">    return this.longOpts.containsKey(opt);</span>
  }

  @Override
  public boolean equals(Object o) {
<span class="fc bfc" id="L122" title="All 2 branches covered.">    if (this == o) {</span>
<span class="fc" id="L123">      return true;</span>
    }
<span class="fc bfc" id="L125" title="All 2 branches covered.">    if (!(o instanceof Options)) {</span>
<span class="fc" id="L126">      return false;</span>
    }
<span class="fc" id="L128">    Options options = (Options) o;</span>
<span class="fc" id="L129">    return Objects.equals(longOpts, options.longOpts);</span>
  }

  @Override
  public int hashCode() {
<span class="fc" id="L134">    return Objects.hash(longOpts);</span>
  }

  @Override
  public String toString() {
<span class="fc" id="L139">    return &quot;Options{&quot; +</span>
        &quot;longOpts=&quot; + this.longOpts +
        &quot;, requiredOpts=&quot; + this.requiredOpts +
        '}';
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>